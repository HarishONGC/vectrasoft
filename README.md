# Centralized CCTV Monitoring Dashboard (SOC-style)

A modern enterprise web dashboard concept for an industrial **Centralized CCTV Monitoring System**.

- **Control Room**: live grid / video wall, real-time camera health, fast filtering and navigation.
- **Admin Console**: location + camera inventory management, bulk import, health check settings, audit logs.

UI defaults to a **daylight-optimized light theme** (background `#F5F7FA`), with optional Dark Mode.

This repo ships with a runnable **React + Tailwind** UI and a small **Node/Express + Socket.IO** demo backend.

## Quick start

### One-command dev (root)

```bash
npm run dev
```

This starts backend (`:4000`) + frontend (`:5173`).

### 1) Backend (REST + WebSocket)

```bash
cd backend
npm install
npm run dev
```

Backend runs on `http://localhost:4000`.

### 2) Frontend (React)

```bash
cd frontend
npm install
npm run dev
```

Frontend runs on `http://localhost:5173`.

## Navigation flow

- `/login`
  - Choose **OPERATOR** (Control Room) or **ADMIN** (Admin Console)
- `/control-room`
  - Control room dashboard (live grid, filters, selected camera panel)
  - Video wall mode: `/control-room?wall=1`
  - Fullscreen: click the expand icon on any camera tile
- `/admin/locations`
  - Add/edit/delete locations
- `/admin/cameras`
  - Add/edit/delete cameras, bulk import, export CSV
- `/admin/settings`
  - Health check settings (ping interval, timeout, unstable threshold)
- `/admin/audit`
  - Audit log viewer

## Component hierarchy (frontend)

- `layouts/ControlRoomLayout`
  - `pages/ControlRoomDashboardPage`
    - `KpiCard` (top summary)
    - `LocationsTree` (left)
    - `CameraTile` grid (center)
    - `CameraDetailsPanel` (right)
- `layouts/AdminLayout`
  - `pages/admin/*`

## Wireframe-level layout

Control Room:

- **Top**: Summary KPI cards (Total / Online / Offline / Warning)
- **Left**: Locations tree view (All + per-location list)
- **Center**: Live camera grid (2x2, 3x3, 4x4)
- **Right**: Selected camera details (RTSP/IP/vendor/type/latency/last seen)

Admin:

- **Left nav**: Locations / Cameras / Health Settings / Audit Logs
- **Main**: Table + edit dialogs, bulk import/export actions

## Real-time updates

- Backend emits `cameraStatusSnapshot` via Socket.IO every few seconds.
- Frontend listens and updates camera status, latency, signal strength.
- REST queries auto-refresh every 5 seconds for a polling-based fallback.

## Ngrok tunneling (dev)

You can expose the dev app over an ngrok tunnel.

1) Start the app:

```bash
npm run dev
```

2) Start ngrok (separate terminals):

```bash
ngrok http 5173
ngrok http 4000
```

3) Set env vars for the frontend (Vite):

```bash
VITE_API_BASE_URL=https://<your-backend-ngrok-domain>/api
VITE_WS_URL=https://<your-backend-ngrok-domain>
VITE_DEV_TUNNEL_HOST=<your-frontend-ngrok-domain>
```

4) Allow tunnel origins on the backend:

```bash
CORS_ALLOW_TUNNELS=1
```

Notes:

- If you use a custom ngrok domain, you can also set `CORS_ORIGIN` to that exact URL.
- RTSP/HLS/WHEP streams on private IPs won’t be reachable from the public internet unless you also expose or proxy the streaming gateway.

## Streaming integration notes (RTSP → Web)

This demo supports **real HLS playback** when a camera has an `hlsUrl` configured.

- The seed camera `Gate-01` includes a demo HLS URL so you can immediately confirm playback.
- For your cameras, you still store the RTSP URL, but the browser will play **HLS** (or WebRTC) generated by a gateway.

Typical production approaches:

- **WebRTC** (lowest latency): RTSP → WebRTC gateway (e.g., GStreamer/Janus/mediasoup)
- **HLS/LL-HLS** (simpler ops, higher latency): RTSP → HLS (FFmpeg) and play via hls.js

You would replace the `CameraTile` placeholder with your chosen player component.

### HLS requirements

- Each camera should have `hlsUrl` like `http(s)://<gateway>/<stream>/index.m3u8`
- The HLS server/gateway must allow **CORS** from the frontend origin (`http://localhost:5173` in dev)
- For broad browser support, ensure the camera/gateway outputs **H.264 (AVC)**. Many browsers do not support **H.265/HEVC** via hls.js, and some H.265 streams can cause HLS segmenting errors.

### Local RTSP→HLS conversion (MediaMTX)

This repo includes a ready-to-run **MediaMTX** config that pulls RTSP cameras and serves HLS.

- Config: [streaming/mediamtx.yml](streaming/mediamtx.yml)
- Compose: [streaming/docker-compose.yml](streaming/docker-compose.yml)

When running, HLS URLs will be available at:

- `http://localhost:8888/<path>/index.m3u8`

The backend seed includes a **Kesanapalli** location with four cameras that use:

- RTSP: `rtsp://live:WSS4Bosch!@117.236.225.209:554` (and .211 / .212 / .213)
- HLS: `http://localhost:8888/kesanapalli-0X/index.m3u8`

If some cameras show a stream error while others work, check the codec:

- If MediaMTX logs show the stream is **H265**, switch that camera stream profile to **H264** (or point the RTSP URL to an H264 substream) and restart MediaMTX.

Start the converter (requires Docker):

```bash
cd streaming
docker compose up -d
```

If you see `docker : The term 'docker' is not recognized`, install **Docker Desktop for Windows** (or use the no-Docker option below).

### No-Docker option (Windows)

You can run MediaMTX directly as a Windows executable:

1) Download MediaMTX for Windows from: `https://github.com/bluenviron/mediamtx/releases`
2) Extract and copy `mediamtx.exe` into the [streaming](streaming) folder.
3) Run:

```powershell
cd streaming
./run-mediamtx.ps1
```

If you prefer to run it in the background (not tied to the current terminal), use:

```powershell
cd streaming
./start-mediamtx.ps1
```

Stop it with:

```powershell
cd streaming
./stop-mediamtx.ps1
```

## Bulk import template

The importer accepts either simple/camel headers or enterprise-style headers, for example:

- `Camera Name`, `Location` (or `Location Code`), `Area/Zone`, `IP Address`, `RTSP URL`, `Camera Type`, `Vendor`, `Installation Date`

## Notes

- RBAC is demoed via a role selector at login (stored in localStorage).
- Audit logs are captured server-side for admin changes.
- This is a UI/UX and architecture starter; connect to your real DB and health checks to go production.
